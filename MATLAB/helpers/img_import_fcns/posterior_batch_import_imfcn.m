function results = posterior_batch_import_imfcn(varargin)
%Image Processing Function
%
% VARARGIN - Can contain up to two inputs: 
%   IM - First input is a numeric array containing the image data. 
%   INFO - Second input is a scalar structure containing information about 
%          the input image source.
%
%   INFO can be used to obtain metadata about the image read. 
%   To apply a batch function using the INFO argument, you must select the 
%   Include Image Info check box in the app toolstrip.
%   
% RESULTS - A scalar struct with the processing results.
%
% 
%
%--------------------------------------------------------------------------
% Auto-generated by imageBatchProcessor App. 
%
% When used by the App, this function will be called for each input image
% file automatically.
%
%--------------------------------------------------------------------------

% Input parsing------------------------------------------------------------
im = varargin{1};

if nargin == 2
    % Obtain information about the input image source
    info = varargin{2};
end

% Replace the sample below with your code----------------------------------
%radius = 4;
%decomposition = 6;
%sigma = 59; % You can adjust the sigma value
% sigma = [10, 59]; % You can adjust the sigma value


a_shape = size(im);

ex_lap_sizes = [1024, 449];
ex_ripple_sizes = [1024, 143];

ex_lap_to_ripple_size_ratio = ex_ripple_sizes ./ ex_lap_sizes;
lap_to_ripple_size_ratio = ex_lap_to_ripple_size_ratio .* a_shape;

% Laps:
parameters.radius = 4;
parameters.decomposition = 6;
parameters.sigma = 59; % You can adjust the sigma value
% parameters.sigma = [10, 59]; % You can adjust the sigma value

% Ripples:
%parameters.radius = 4;
%parameters.decomposition = 6;
%parameters.sigma = 59; % You can adjust the sigma value
% sigma = [10, 59]; % You can adjust the sigma value

%lap_to_ripple_size_ratio = [1.0000,	0.3185];


% Ripples:
parameters.radius = round(parameters.radius * min(lap_to_ripple_size_ratio));
%parameters.decomposition = round(parameters.decomposition * min(lap_to_ripple_size_ratio)); % ALWAYS needs to be 6, the connectivity to use
% parameters.sigma = round(parameters.sigma * min(lap_to_ripple_size_ratio));
parameters.sigma = parameters.sigma * min(lap_to_ripple_size_ratio);

% Adjust data to span data range.
im = imadjust(im);
imgray = im2gray(im);
bw = imbinarize(imgray);
% bw = imcomplement(bw);

results.imgray = imgray;
results.bw = bw;

%% Processing:

% [results.maxEig, results.ridges] = ridgefilt(imgray, 1, 2, 0.5);
% [BW, maskedImage, blurredImg] = fn_segimg_replay_connect(imgray, sigma, radius, decomposition);
[BW, maskedImage, blurredImg] = fn_segimg_replay_connect(imgray, parameters.sigma, parameters.radius, parameters.decomposition);
results.seg_bw = BW;
results.seg_maskedImage = maskedImage;
results.blurredImg = blurredImg;

results.E = IM.get_ellipse(BW);                % Compute the equivalent ellipse
% expand the .E struct and add fields to results
fields = fieldnames(results.E);
for i = 1:numel(fields)
    results.(fields{i}) = results.E.(fields{i});
end

% Draw the ellipse overlaying the image:
%figure; imshow(BW)
%hold on
%IM.draw_ellipse(E, 'elements', {'ellipse','major','minor','semimajor','direction'}) % , 'color', 'm'

% results.maxEig = maxEig;
% results.ridges = ridges;

%--------------------------------------------------------------------------
