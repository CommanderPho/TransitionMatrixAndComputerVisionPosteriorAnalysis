function result = batchposterior_batch_import_imfcn(source, outDir)
%batchposterior_batch_import_imfcn Batch process images using posterior_batch_import_imfcn
% RESULT = batchposterior_batch_import_imfcn(SOURCE, OUTDIR) processes each file in SOURCE
% using the function posterior_batch_import_imfcn.
%
% The following fields from the output of posterior_batch_import_imfcn are written with their
% corresponding file format to the output directory OUTDIR:

%
% The following fields are returned in the table RESULT
%    E
%    blurredImg
%    bw
%    imgray
%    l
%    m00
%    m01
%    m02
%    m10
%    m11
%    m20
%    parameters
%    seg_bw
%    seg_maskedImage
%    theta
%    w
%    x
%    x1
%    x2
%    y
%    y1
%    y2

%
% Auto-generated by imageBatchProcessor app on 2024-08-28
%----------------------------------------------------------

narginchk(0, 2);

if nargin == 0
    source = "E:\Dropbox (Personal)\Active\Kamran Diba Lab\Pho-Kamran-Meetings\2024-08-20 - Finalizing Transition Matrix\_temp_individual_posteriors\2024-08-27\ripple\greyscale";
    outDir = "";
elseif nargin == 1
    validateattributes( source, ...
        ["char", "string",  "matlab.io.datastore.ImageDatastore"], {}, ...
        "batchposterior_batch_import_imfcn", "source" );
    outDir = "";
else
    outDir = string(outDir);
end

source = convertCharsToStrings(source);

% Fields to place in result
workSpaceFields = {
    'E','blurredImg','bw','imgray','l','m00','m01','m02','m10','m11','m20','parameters','seg_bw','seg_maskedImage','theta','w','x','x1','x2','y','y1','y2','fileName'
    };

% Fields to write out to files. Each entry contains the field name and the
% corresponding file format.
fileFieldsAndFormat = {

};

% If the images are being loaded from a folder, create an imageDatastore
% to read the input images
if isstring(source)
    isInclSubFolders = false;
    inIMDS = createInputReader(source, isInclSubFolders);
else
    inIMDS = copy(source);
    reset(inIMDS);
    inIMDS.ReadSize = 1;
end

inDir = inIMDS.Folders{1};

% Initialize output (as struct array)
result(numel(inIMDS.Files)) = struct();
% Initialize fields with []
for ind =1:numel(workSpaceFields)
    [result.(workSpaceFields{ind})] = deal([]);
end

% Process each image using posterior_batch_import_imfcn

imgInd = 1;
while hasdata(inIMDS)
    try
        [im, info] = read(inIMDS);
        inImageFile = info.Filename;
        if isempty(im)
            disp("READ FAILED:" + inImageFile);
            imgInd = imgInd + 1;
            continue;
        end

        % Process
        oneResult = posterior_batch_import_imfcn(im, info);

        % Accumulate
        for ind = 1:numel(workSpaceFields)
            % Only copy fields specified to be returned in the output
            fieldName = workSpaceFields{ind};
            if fieldName == "fileName"
                continue;
            end
            % fullFilePath = oneResult.(fieldName);
            result(imgInd).(fieldName) = oneResult.(fieldName);
        end

        % Include the input image file name
        result(imgInd).fileName = inIMDS.Files{imgInd};
        % extract the basename
        fullFilePath = result(imgInd).fileName;
        [~, aBaseName, ~] = fileparts(fullFilePath);
        result(imgInd).baseName = aBaseName; 
        % Use regexp to extract numbers within brackets
        epoch_idx = regexp(aBaseName, '\[(\d+)\]', 'tokens');

        % Convert extracted cell array of tokens to numeric array
        if ~isempty(epoch_idx)
            % Convert to numeric if tokens found
            epoch_idx = cellfun(@(x) str2double(x{1}), epoch_idx);
            result(imgInd).epochIdx = epoch_idx;
        else
            % Handle cases where no epoch index is found
            result(imgInd).epochIdx = NaN; % or any default value you prefer
        end

        % Write chosen fields to image files only if output directory is
        % specified
        if outDir ~= ""
            % Output has the same sub-directory structure as input
            outImageFileWithExtension = replace(inImageFile, inDir, outDir);

            % Remove the file extension to create the template output file name
            [path, filename,~] = fileparts(outImageFileWithExtension);
            outImageFile = fullfile(path,filename);

            % Create (sub)directory if needed
            outSubDir = fileparts(outImageFile);
            createDirectory(outSubDir);

            for ind = 1:numel(fileFieldsAndFormat)
                fieldName  = fileFieldsAndFormat{ind}{1};
                fileFormat = fileFieldsAndFormat{ind}{2};
                imageData  = oneResult.(fieldName);
                % Add the field name and required file format for this
                % field to the template output file name
                outImageFileWithExtension = outImageFile + "_"  + fieldName + "." + fileFormat;

                try
                    switch(fileFormat)
                        case "dcm"
                            dicomwrite(imageData, outImageFileWithExtension);
                        case "exr"
                            exrwrite(imageData, outImageFileWithExtension);
                        otherwise
                            imwrite(imageData, outImageFileWithExtension);
                    end
                catch IMAGEWRITEFAIL
                    disp("WRITE FAILED:" + inImageFile);
                    warning(IMAGEWRITEFAIL.identifier, "%s", IMAGEWRITEFAIL.message);
                end
            end
            disp("PASSED:" + inImageFile);
        else
            disp("PASSED:" + inImageFile);
        end

    catch READANDPROCESSEXCEPTION
        disp("FAILED:" + inImageFile);
        warning(READANDPROCESSEXCEPTION.identifier, "%s", READANDPROCESSEXCEPTION.message);
    end
    imgInd = imgInd + 1;
end

result = struct2table(result,"AsArray",true);

end

function createDirectory(dirname)
% Make output (sub) directory if needed
if exist(dirname, "dir")
    return;
end
[success, message] = mkdir(dirname);
if ~success
    disp("FAILED TO CREATE:" + dirname);
    disp(message);
end
end

function imds = createInputReader(inDir, isRecurse)
% Helper function that creates the datastore to read from folder of images

% All supported extensions
supportedExtns = supportedFormats();

% Create a image data store that can read all these files
imds = imageDatastore(inDir,...
    IncludeSubfolders=isRecurse,...
    FileExtensions=supportedExtns, ...
    ReadFcn = @readImage);

end

function im = readImage(fileName)
% Helper function that reads an image from a file.
% Returns an empty matrix if there is an error reading the file

try
    im = readAllIPTFormats(fileName);
catch
    im = [];
end
end

function formats = supportedFormats()
% Returns a cell array of formats supported by readAllIPTFormats()

% Copyright 2020-2022 The MathWorks, Inc.

imf = imformats;
formats = strcat('.',[imf.ext]);

% IPT extensions
formats = [formats, ...
    {'.dcm'},...
    {'.dic'},...
    {'.ima'},...
    {'.ntf'},...
    {'.nitf'},...
    {'.dpx'},...
    {'.exr'}];

rawFormats = {'.dng', '.nef','.cr2','.crw','.arw','.raf','.kdc','.mrw','.orf','.raw','.rw2','.srw','.pef','.x3f','.DNG','.NEF','.CR2','.CRW','.ARW','.RAF','.KDC','.MRW','.ORF','.RAW','.RW2','.SRW','.PEF','.X3F'};
formats = [formats, rawFormats ];

end

function [im, cmap] = readAllIPTFormats(filename, options)
% readAllIPTFormats read all image formats supported by IPT
%  [im, cmap] = readAllIPTFormats(FILENAME) attempts to read FILENAME
%  as an image file using this list of readers:
%       * Previously cached reader function handle
%       * RAW files
%       * IMREAD wrapper
%       * DICOM wrapper
%       * NITF
%       * DPX
%       * EXR
%       * HDR
%
%  On read failure, issues as informative an exception as possible to the
%  user.
%
% Note: Caches last successfully used image read function. This improves
% performance of reading a list of similar format files.
%
% Note: keep in sync with supportedFormats()

% Copyright 2020-2022 The MathWorks, Inc.

arguments
    filename (1,1) string

    % Supported input values are:
    % 1. integer-valued positive scalar
    % 2. Character vector or string scalar with the value "default"
    %
    % The "default" behaviour will be resolved by the specific reader used.
    options.ImageIndex  { mustBeA( options.ImageIndex, ...
        ["numeric", "char", "string"] ) } = "default"
end

ME = [];

% Verify if the file exists
try
    filename = images.internal.io.absolutePathForReading(filename);
catch ME
    throwAsCaller(ME);
end

options = convertContainedStringsToChars(options);
if ischar(options.ImageIndex)
    options.ImageIndex = validatestring(options.ImageIndex, "default");
else
    validateattributes( options.ImageIndex, "double", ...
        ["integer", "positive"], "readAllIPTFormats" );
end

persistent cachedReader;

allWarnsOff = warning('off');
restoreWarnObj = onCleanup(@()warning(allWarnsOff));

prevReader = cachedReader;

try
    % A few checks to perform before trying the cached reader

    % Some RAW files are read by IMREAD. However, these return the preview
    % image instead.
    if isequal(cachedReader, @imreadWrapper) && hasRAWExtn(filename)
        % No need to translate as it is caught internally
        throw("Cannot use IMREAD for these files");
    end

    % with the previously cached reader first
    [im, cmap] = cachedReader(filename, options.ImageIndex);
catch
    % That failed, so do a fresh search using all known readers
    [im, cmap, cachedReader, ME] = ...
        findReaderAndRead(filename, options.ImageIndex);
end

if ~isempty(ME)
    cachedReader = prevReader;
    throwAsCaller(ME);
end

end

%------------------------------------------------------------
function [im, cmap, cachedReader, ME] = ...
    findReaderAndRead(fileName, idx)

cachedReader = [];
ME = MException.empty();

im = [];
cmap = [];

try
    % Unfortunately, there is no isRAW function. Hence, an exception
    % can be due to a corrupt RAW file or not a RAW file. Going to
    % treat it as the latter.
    [im, cmap] = raw2rgbWrapper(fileName, idx);
    cachedReader = @raw2rgbWrapper;
catch MEraw
    % If the file does not have a recognized RAW format extension, then
    % try other readers. If not, report the exception received.
    if ~hasRAWExtn(fileName)
        [im, cmap, cachedReader, ME] = tryImreadAndIPTreads(fileName, idx);
    else
        ME = MEraw;
    end
end
end

%------------------------------------------------------------
function [im, cmap, cachedReader, ME] = tryImreadAndIPTreads(fileName, idx)
% Read this image using IMREAD and other supported IPT image readers.

ME = MException.empty();
im = [];
cmap = [];
cachedReader = [];

try
    % Since there is no way to detect if a file can be read by IMREAD, we
    % have to try and read it
    [im, cmap] = imreadWrapper(fileName, idx);
    cachedReader = @imreadWrapper;

catch MEimread
    % Try other IPT format readers
    try
        [im, cmap, cachedReader] = readIPTFormats(fileName, idx);

        % Indicates the file name was not detected as a supported IPT
        % format
        if isempty(im)
            ME = MEimread;
        end

    catch MEipt
        % Exception generated indicates the fileName was detected as being
        % a supported file format but reading the file failed.
        ME = MEipt;
    end
end
end

%------------------------------------------------------------
function [im, cmap, cachedReader] = readIPTFormats(fileName, idx)
% Try to read other IPT file formats.

% This function will throw an exception only if the fileName was infact
% detected as a supported file but reading the file failed.

% If the file was not detected as a supported format, it will return an
% empty image array.

im = [];
cmap = [];
cachedReader = [];

if isdicom(fileName)
    [im, cmap] = dicomreadWrapper(fileName, idx);
    cachedReader = @dicomreadWrapper;
elseif isexr(fileName)
    [im, cmap] = exrreadWrapper(fileName, idx);
    cachedReader = @exrreadWrapper;
elseif images.internal.hdr.ishdr(fileName)
    [im, cmap] = hdrreadWrapper(fileName, idx);
    cachedReader = @hdrreadWrapper;
elseif isnitf(fileName)
    [im, cmap] = nitfreadWrapper(fileName, idx);
    cachedReader = @nitfreadWrapper;
elseif isdpx(fileName)
    [im, cmap] = dpxreadWrapper(fileName, idx);
    cachedReader = @dpxreadWrapper;
end
end

%------------------------------------------------------------
function [im, cmap] = raw2rgbWrapper(fileName, idx)
% Wrap raw2rgb

if isnumeric(idx) && idx > 1
    error(message("images:readAllIPTFormats:MultipageUnsupported"));
end

im = raw2rgb(fileName);
cmap = [];
end

%------------------------------------------------------------
function [im, cmap] = imreadWrapper(fileName, idx)
% Wrap IMREAD

% Perform default read when requested. IMREAD does not even accept an index
% argument = 1 for file formats that are not multi-page.
if isstring(idx)
    [im, cmap] = imread(fileName);
    return;
end

if endsWith(fileName, [".gif", ".pgm", ".ppm", ".pbm", ".ppm", ".cur", ".ico", ".tif", ".svs", ".hdf"])
    [im, cmap] = imread(fileName, idx);
else
    if idx > 1
        error(message("images:readAllIPTFormats:MultipageUnsupported"));
    end
    [im, cmap] = imread(fileName);
end

end

%------------------------------------------------------------
function [im, cmap] = dicomreadWrapper(fileName, idx)
% Wrap DICOMREAD, apply colormap if present

if isstring(idx)
    % The default beheaviour of DICOMREAD is to read all the frames
    % from the file.
    idx = "all";
end
[im, cmap] = dicomread(fileName, Frames=idx);

% DICOMREAD returns an empty matrix for any non-DICOM file.
if isempty(im)
    error(message('images:readAllIPTFormats:NoImage'));
end

end

%------------------------------------------------------------
function [im, cmap] = nitfreadWrapper(fileName, idx)
% Wrap NITF reading functionality

if isstring(idx)
    idx = 1;
end

im = nitfread(fileName, idx);
cmap = [];
end

%------------------------------------------------------------
function [im, cmap] = dpxreadWrapper(fileName, idx)
% Wrap DPX reading functionality

if isnumeric(idx) && idx > 1
    error(message("images:readAllIPTFormats:MultipageUnsupported"));
end

im = dpxread(fileName);
cmap = [];
end

%------------------------------------------------------------
function [im, cmap] = exrreadWrapper(fileName, idx)
% Wrap exrread

if isstring(idx)
    idx = 1;
end

im = exrread(fileName, PartIdentifier=idx);
cmap = [];
end

%------------------------------------------------------------
function [im, cmap] = hdrreadWrapper(fileName, idx)
% Wrap hdrread

if isnumeric(idx) && idx > 1
    error(message("images:readAllIPTFormats:MultipageUnsupported"));
end
im = hdrread(fileName);
cmap = [];
end

%------------------------------------------------------------
function tf = hasRAWExtn(fileName)
% Helper function that checks if the input file contains a known RAW file
% extension

rawFormats =  [ ".dng",".nef",".cr2",".crw",".arw",".raf",".kdc", ...
    ".mrw",".orf",".raw",".rw2",".srw",".pef",".x3f", ...
    ".DNG",".NEF",".CR2",".CRW",".ARW",".RAF",".KDC", ...
    ".MRW",".ORF",".RAW",".RW2",".SRW",".PEF",".X3F" ];

tf = endsWith(fileName, rawFormats);
end

